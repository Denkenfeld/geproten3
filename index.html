<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TastenZauber - Tippen lernen f√ºr Kinder</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@300;400;600&display=swap" rel="stylesheet">

    <style>
        /* --- CSS STYLING --- */
        :root {
            --primary: #FF9AA2;
            --secondary: #B5EAD7;
            --accent: #FFB7B2;
            --text: #6d5c6d;
            --dark: #4A404F;
            --keyboard-bg: rgba(255, 255, 255, 0.85);
            --key-bg: #fff;
            --key-active: #C7CEEA;
        }

        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Fredoka', sans-serif;
            background-color: #E2F0CB;
            color: var(--text);
            user-select: none;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* --- UI OVERLAY --- */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none; /* Let clicks pass to 3D if needed, though we use buttons */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .ui-element {
            pointer-events: auto;
        }

        /* --- HEADER & STATS --- */
        header {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .score-box {
            background: white;
            padding: 10px 20px;
            border-radius: 30px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            font-size: 1.2rem;
            font-weight: 600;
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .progress-container {
            width: 300px;
            height: 20px;
            background: rgba(255,255,255,0.5);
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #FF9AA2, #FFB7B2);
            width: 0%;
            transition: width 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        /* --- CENTER DISPLAY --- */
        #target-display {
            position: absolute;
            top: 30%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            text-shadow: 0 2px 0 rgba(255,255,255,0.5);
        }

        #current-char {
            font-size: 6rem;
            color: white;
            text-shadow: 0 4px 15px rgba(0,0,0,0.2);
            font-weight: bold;
            animation: float 3s ease-in-out infinite;
        }

        #next-chars {
            font-size: 1.5rem;
            color: rgba(255,255,255,0.7);
            letter-spacing: 5px;
            margin-top: 10px;
        }

        /* --- KEYBOARD --- */
        #keyboard-wrapper {
            margin-bottom: 20px;
            display: flex;
            justify-content: center;
            width: 100%;
        }

        .keyboard {
            background: var(--keyboard-bg);
            padding: 20px;
            border-radius: 20px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            backdrop-filter: blur(5px);
            display: grid;
            grid-template-rows: repeat(4, 1fr);
            gap: 8px;
            width: 800px;
        }

        .row {
            display: flex;
            justify-content: center;
            gap: 8px;
        }

        .key {
            width: 50px;
            height: 50px;
            background: var(--key-bg);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.1rem;
            box-shadow: 0 4px 0 #ddd;
            color: var(--dark);
            transition: all 0.1s;
        }

        .key.wide { width: 80px; }
        .key.space { width: 300px; }

        .key.active {
            background: var(--primary);
            color: white;
            box-shadow: 0 4px 0 #D68C94;
            transform: translateY(2px);
            border: 2px solid white;
        }

        .key.pressed {
            transform: translateY(4px);
            box-shadow: 0 0 0 #ddd;
        }

        /* --- MENUS --- */
        .overlay-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.9);
            z-index: 100;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
        }

        .hidden { display: none !important; }

        h1 { font-size: 4rem; color: var(--primary); margin: 0; text-shadow: 2px 2px 0 #fff; }
        h2 { color: var(--text); }

        .btn {
            background: var(--secondary);
            border: none;
            padding: 15px 40px;
            border-radius: 50px;
            font-size: 1.5rem;
            font-family: 'Fredoka', sans-serif;
            font-weight: bold;
            color: var(--dark);
            cursor: pointer;
            margin: 10px;
            box-shadow: 0 5px 0 #8AC6B3;
            transition: transform 0.1s;
        }
        .btn:hover { transform: scale(1.05); }
        .btn:active { transform: scale(0.95) translateY(5px); box-shadow: none; }
        .btn.small { padding: 10px 20px; font-size: 1rem; }

        .level-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-top: 30px;
        }
        
        .level-btn {
            background: #fff;
            border: 2px solid var(--secondary);
            padding: 15px;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .level-btn:hover { background: var(--secondary); }
        .level-btn.locked { opacity: 0.5; cursor: not-allowed; background: #eee; }

        /* --- ANIMATIONS --- */
        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-20px); }
        }

        @keyframes shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
            100% { transform: translateX(0); }
        }
        .shake { animation: shake 0.3s; }

        /* --- MINI GAME --- */
        #mini-game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 50;
            background: rgba(0,0,0,0.3);
            display: none;
        }
    </style>
</head>
<body>

    <div id="canvas-container"></div>
    <canvas id="mini-game-canvas"></canvas>

    <div id="ui-layer" class="hidden">
        <header class="ui-element">
            <button class="btn small" id="btn-menu">üè† Men√º</button>
            <div class="score-box">
                <span>‚≠ê <span id="score-val">0</span></span>
                <div class="progress-container">
                    <div class="progress-bar" id="prog-bar"></div>
                </div>
            </div>
            <button class="btn small" id="btn-sound">üîä An</button>
        </header>

        <div id="target-display">
            <div id="current-char">Start!</div>
            <div id="next-chars"></div>
        </div>

        <div id="keyboard-wrapper" class="ui-element">
            <div class="keyboard" id="onscreen-keyboard">
                </div>
        </div>
    </div>

    <div id="start-screen" class="overlay-screen">
        <h1>TastenZauber</h1>
        <h2>Lerne Tippen mit dem magischen Fuchs!</h2>
        <button class="btn" id="btn-start-game">Los geht's!</button>
        <p style="margin-top: 20px; font-size: 0.8rem; color: #999;">Tipp: Schalte den Ton ein üîä</p>
    </div>

    <div id="level-screen" class="overlay-screen hidden">
        <h1>Level Auswahl</h1>
        <div class="level-grid" id="level-container">
            </div>
    </div>

    <div id="modal-screen" class="overlay-screen hidden" style="background: rgba(255,255,255,0.8);">
        <h1 id="modal-title">Super!</h1>
        <p id="modal-desc">Level geschafft!</p>
        <button class="btn" id="btn-modal-action">Weiter</button>
    </div>

    <script>
        /**
         * TastenZauber - Main Application Logic
         */

        // --- LEVEL DATA (German QWERTZ Progression) ---
        const LEVELS = [
            { id: 1, name: "Grundstellung 1", keys: "fj", content: "fff jjj fjfj jfjf fff jjj fjf jfj" },
            { id: 2, name: "Grundstellung 2", keys: "dk", content: "ddd kkk ddkk kkdd djdk kdfj" },
            { id: 3, name: "Grundstellung 3", keys: "sl", content: "sss lll slsl lssl sldk fjls" },
            { id: 4, name: "Grundstellung 4", keys: "a√∂", content: "aaa √∂√∂√∂ a√∂a√∂ √∂a√∂a asdf jkl√∂" },
            { id: 5, name: "Zeigefinger", keys: "gh", content: "ggg hhh ghgh hghg fghj jhgf lag jagd" },
            { id: 6, name: "W√∂rter 1", keys: "all", content: "hallo da als das glas ja saal fass" },
            { id: 7, name: "Oberreihe 1", keys: "ru", content: "rrr uuu ru ru ruf ufer sau raus" },
            { id: 8, name: "Oberreihe 2", keys: "ei", content: "eee iii ei ei eis reis lies sie" },
        ];

        // --- AUDIO MANAGER (UPDATED: Calm Piano & Lullaby) ---
        class AudioManager {
            constructor() {
                this.ready = false;
                this.enabled = true;
                
                // --- Effects ---
                // Reverb to make it dreamy
                this.reverb = new Tone.Reverb({
                    decay: 2.5,
                    wet: 0.4
                }).toDestination();

                // --- Instruments ---
                
                // 1. Piano (for correct keys)
                // Using a PolySynth with a specific envelope to sound like a soft Electric Piano / Rhodes
                this.piano = new Tone.PolySynth(Tone.Synth, {
                    oscillator: { type: "sine" }, // Sine wave is soft
                    envelope: {
                        attack: 0.01,
                        decay: 0.3,
                        sustain: 0.1,
                        release: 1.5
                    },
                    volume: -8
                }).connect(this.reverb);

                // 2. Error Sound (Soft thud, not annoying)
                this.errorSynth = new Tone.MembraneSynth({
                    pitchDecay: 0.05,
                    octaves: 2,
                    oscillator: { type: "sine" },
                    envelope: {
                        attack: 0.001,
                        decay: 0.2,
                        sustain: 0,
                        release: 1
                    },
                    volume: -5
                }).toDestination();

                // 3. Background Music Synth (Pad-like)
                this.bgmSynth = new Tone.PolySynth(Tone.Synth, {
                    oscillator: { type: "triangle" },
                    envelope: {
                        attack: 2,
                        decay: 1,
                        sustain: 0.5,
                        release: 3
                    },
                    volume: -20
                }).connect(this.reverb);

                // Add a lowpass filter to BGM to make it "underwater" / gentle
                this.bgmFilter = new Tone.Filter(600, "lowpass").toDestination();
                this.bgmSynth.connect(this.bgmFilter);
            }

            async init() {
                if (this.ready) return;
                await Tone.start();
                this.ready = true;
                this.startBGM();
            }

            toggle() {
                this.enabled = !this.enabled;
                if(this.enabled) {
                    Tone.Destination.mute = false;
                    return true;
                } else {
                    Tone.Destination.mute = true;
                    return false;
                }
            }

            playCorrect() {
                if (!this.ready || !this.enabled) return;
                // Pentatonic Scale (C Major Pentatonic) - Always sounds good together
                // Notes: C4, D4, E4, G4, A4
                const scale = ["C4", "D4", "E4", "G4", "A4", "C5"];
                const note = scale[Math.floor(Math.random() * scale.length)];
                
                // Short, gentle chime
                this.piano.triggerAttackRelease(note, "8n");
            }

            playWrong() {
                if (!this.ready || !this.enabled) return;
                // Low, soft thud (gentle reminder)
                this.errorSynth.triggerAttackRelease("C2", "8n");
            }

            playWin() {
                if (!this.ready || !this.enabled) return;
                const now = Tone.now();
                // A happy C Major arpeggio, played softly
                this.piano.triggerAttackRelease("C4", "8n", now);
                this.piano.triggerAttackRelease("E4", "8n", now + 0.2);
                this.piano.triggerAttackRelease("G4", "8n", now + 0.4);
                this.piano.triggerAttackRelease("C5", "1n", now + 0.6);
            }

            startBGM() {
                // Slower, ambient progression (Lullaby style)
                Tone.Transport.bpm.value = 60; // Slow tempo

                // Progression: I - IV - I - V (C Maj -> F Maj -> C Maj -> G Maj)
                const chords = [
                    ["C3", "E3", "G3"], 
                    ["F3", "A3", "C4"],
                    ["C3", "E3", "G3"],
                    ["G3", "B3", "D4"]
                ];

                let chordIndex = 0;

                const loop = new Tone.Loop(time => {
                    if (!this.enabled) return;
                    
                    const currentChord = chords[chordIndex % chords.length];
                    // Play chord very softly and long
                    this.bgmSynth.triggerAttackRelease(currentChord, "1m", time); // 1 measure length
                    
                    chordIndex++;
                }, "1m").start(0);

                Tone.Transport.start();
            }
        }

        // --- 3D GRAPHICS (Three.js) ---
        class World3D {
            constructor(containerId) {
                this.container = document.getElementById(containerId);
                
                // Scene Setup
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.FogExp2(0xE2F0CB, 0.02);

                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 2, 8);
                this.camera.lookAt(0, 1, 0);

                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.container.appendChild(this.renderer.domElement);

                // Lighting
                const hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.6);
                this.scene.add(hemiLight);
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
                dirLight.position.set(5, 10, 7);
                this.scene.add(dirLight);

                // Objects
                this.mascot = new THREE.Group();
                this.createMascot();
                this.scene.add(this.mascot);

                this.createEnvironment();
                this.createParticles();

                // Resize handler
                window.addEventListener('resize', () => this.onResize());

                // Animation Loop
                this.clock = new THREE.Clock();
                this.animate();
            }

            createMascot() {
                // "Minecraft" Style Fox/Robot
                const matBody = new THREE.MeshStandardMaterial({ color: 0xFF9AA2 }); // Pink
                const matWhite = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                const matDark = new THREE.MeshStandardMaterial({ color: 0x333333 });

                // Body
                const body = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1.5, 1.5), matBody);
                body.position.y = 1;
                this.mascot.add(body);

                // Head
                const head = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.2, 1.2), matBody);
                head.position.y = 2.4;
                this.mascot.add(head);

                // Ears
                const earL = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.2), matBody);
                earL.position.set(-0.4, 3.1, 0);
                this.mascot.add(earL);
                const earR = earL.clone();
                earR.position.set(0.4, 3.1, 0);
                this.mascot.add(earR);

                // Eyes
                const eyeL = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 0.1), matDark);
                eyeL.position.set(-0.3, 2.4, 0.6);
                this.mascot.add(eyeL);
                const eyeR = eyeL.clone();
                eyeR.position.set(0.3, 2.4, 0.6);
                this.mascot.add(eyeR);

                // Snout
                const snout = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.3, 0.2), matWhite);
                snout.position.set(0, 2.1, 0.65);
                this.mascot.add(snout);

                this.mascotBaseY = 0;
            }

            createEnvironment() {
                // Floating Islands
                const geometry = new THREE.CylinderGeometry(3, 1, 3, 6);
                const material = new THREE.MeshStandardMaterial({ color: 0xB5EAD7, flatShading: true });
                
                const mainIsland = new THREE.Mesh(geometry, material);
                mainIsland.position.y = -2;
                this.scene.add(mainIsland);

                for(let i=0; i<5; i++) {
                    const smol = new THREE.Mesh(geometry, material);
                    smol.scale.set(0.3, 0.3, 0.3);
                    smol.position.set(
                        (Math.random() - 0.5) * 15,
                        (Math.random() * 5) - 2,
                        (Math.random() - 0.5) * 10 - 5
                    );
                    this.scene.add(smol);
                }
            }

            createParticles() {
                const geometry = new THREE.BufferGeometry();
                const vertices = [];
                for ( let i = 0; i < 200; i ++ ) {
                    vertices.push(
                        THREE.MathUtils.randFloatSpread( 20 ),
                        THREE.MathUtils.randFloatSpread( 20 ),
                        THREE.MathUtils.randFloatSpread( 20 )
                    );
                }
                geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );
                const particles = new THREE.Points( geometry, new THREE.PointsMaterial( { color: 0xFFFFFF, size: 0.1 } ) );
                this.scene.add( particles );
                this.particles = particles;
            }

            jump() {
                // Simple jump trigger
                this.jumpTime = 0;
                this.isJumping = true;
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                const delta = this.clock.getDelta();
                const time = this.clock.getElapsedTime();

                // Mascot Float
                if (this.isJumping) {
                    this.jumpTime += delta * 5;
                    this.mascot.position.y = Math.sin(this.jumpTime) * 1.5;
                    this.mascot.rotation.y += 0.1;
                    if(this.jumpTime > Math.PI) {
                        this.isJumping = false;
                        this.mascot.rotation.y = 0;
                        this.mascot.position.y = 0;
                    }
                } else {
                    this.mascot.position.y = Math.sin(time * 1.5) * 0.2;
                }

                // Particles Rotation
                if(this.particles) this.particles.rotation.y += 0.001;

                this.renderer.render(this.scene, this.camera);
            }

            onResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        // --- GAME LOGIC ---
        class Game {
            constructor() {
                this.audio = new AudioManager();
                this.world = new World3D('canvas-container');
                this.currentLevelIdx = 0;
                this.targetString = "";
                this.currentIndex = 0;
                this.score = 0;
                this.errors = 0;
                this.isGameActive = false;
                this.unlockedLevels = parseInt(localStorage.getItem('tastenZauberLevel')) || 1;

                this.ui = {
                    screens: {
                        start: document.getElementById('start-screen'),
                        game: document.getElementById('ui-layer'),
                        level: document.getElementById('level-screen'),
                        modal: document.getElementById('modal-screen')
                    },
                    display: {
                        current: document.getElementById('current-char'),
                        next: document.getElementById('next-chars'),
                        score: document.getElementById('score-val'),
                        bar: document.getElementById('prog-bar')
                    },
                    keyboard: document.getElementById('onscreen-keyboard')
                };

                this.initKeyboardUI();
                this.setupListeners();
                this.renderLevelSelect();
            }

            // --- KEYBOARD MAPPING (German QWERTZ) ---
            initKeyboardUI() {
                // Simplified German QWERTZ Layout
                const rows = [
                    ["^", "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "√ü", "¬¥"],
                    ["q", "w", "e", "r", "t", "z", "u", "i", "o", "p", "√º", "+"],
                    ["a", "s", "d", "f", "g", "h", "j", "k", "l", "√∂", "√§", "#"],
                    ["<", "y", "x", "c", "v", "b", "n", "m", ",", ".", "-", "SHIFT"]
                ];

                const container = this.ui.keyboard;
                container.innerHTML = "";

                rows.forEach(rowKeys => {
                    const rowDiv = document.createElement('div');
                    rowDiv.className = 'row';
                    rowKeys.forEach(char => {
                        const keyDiv = document.createElement('div');
                        keyDiv.className = 'key';
                        keyDiv.textContent = char.toUpperCase();
                        keyDiv.dataset.char = char; // Store lowercase for matching
                        
                        if(char.length > 1) keyDiv.classList.add('wide');
                        
                        rowDiv.appendChild(keyDiv);
                    });
                    container.appendChild(rowDiv);
                });
                
                // Add Spacebar row
                const spaceRow = document.createElement('div');
                spaceRow.className = 'row';
                const spaceKey = document.createElement('div');
                spaceKey.className = 'key space';
                spaceKey.dataset.char = " ";
                spaceKey.textContent = "LEERTASTE";
                spaceRow.appendChild(spaceKey);
                container.appendChild(spaceRow);
            }

            setupListeners() {
                // Buttons
                document.getElementById('btn-start-game').onclick = () => {
                    this.audio.init();
                    this.showScreen('level');
                };

                document.getElementById('btn-menu').onclick = () => {
                    this.isGameActive = false;
                    this.showScreen('level');
                };

                document.getElementById('btn-sound').onclick = (e) => {
                    const on = this.audio.toggle();
                    e.target.textContent = on ? "üîä An" : "üîá Aus";
                };

                document.getElementById('btn-modal-action').onclick = () => {
                    this.ui.screens.modal.classList.add('hidden');
                    this.startMiniGame();
                };

                // Typing
                window.addEventListener('keydown', (e) => this.handleTyping(e));
                window.addEventListener('keyup', (e) => this.handleKeyUp(e));
            }

            renderLevelSelect() {
                const container = document.getElementById('level-container');
                container.innerHTML = "";
                LEVELS.forEach((lvl, idx) => {
                    const btn = document.createElement('div');
                    btn.className = 'level-btn';
                    const isLocked = (idx + 1) > this.unlockedLevels;
                    
                    if (isLocked) btn.classList.add('locked');
                    btn.innerHTML = `<h3>Level ${lvl.id}</h3><p>${lvl.name}</p>`;
                    
                    if (!isLocked) {
                        btn.onclick = () => this.startLevel(idx);
                    }
                    container.appendChild(btn);
                });
            }

            showScreen(name) {
                Object.values(this.ui.screens).forEach(el => el.classList.add('hidden'));
                if (name === 'game') this.ui.screens.game.classList.remove('hidden');
                else if (name === 'level') {
                    this.renderLevelSelect();
                    this.ui.screens.level.classList.remove('hidden');
                }
                else if (name === 'start') this.ui.screens.start.classList.remove('hidden');
                else if (name === 'modal') this.ui.screens.modal.classList.remove('hidden');
            }

            startLevel(index) {
                this.currentLevelIdx = index;
                this.targetString = LEVELS[index].content;
                this.currentIndex = 0;
                this.score = 0;
                this.isGameActive = true;
                this.updateDisplay();
                this.showScreen('game');
                this.highlightKey(this.targetString[0]);
            }

            handleTyping(e) {
                if (!this.isGameActive) return;

                // Map key code to German char logic roughly if needed, 
                // but usually e.key works fine for modern browsers.
                let char = e.key;

                // Visual Feedback on Keyboard
                const keyEl = this.findKeyElement(char);
                if (keyEl) keyEl.classList.add('pressed');

                // Game Logic
                const expected = this.targetString[this.currentIndex];
                
                if (char === expected) {
                    // Correct
                    this.audio.playCorrect();
                    this.score += 10;
                    this.currentIndex++;
                    this.world.jump(); // Mascot animation
                    
                    // Check completion
                    if (this.currentIndex >= this.targetString.length) {
                        this.levelComplete();
                    } else {
                        this.updateDisplay();
                        this.highlightKey(this.targetString[this.currentIndex]);
                    }
                } else {
                    // Ignore modifiers
                    if (char.length === 1) {
                        this.audio.playWrong();
                        this.ui.display.current.classList.add('shake');
                        setTimeout(() => this.ui.display.current.classList.remove('shake'), 300);
                    }
                }
                
                this.ui.display.score.innerText = this.score;
            }

            handleKeyUp(e) {
                const keyEl = this.findKeyElement(e.key);
                if (keyEl) keyEl.classList.remove('pressed');
            }

            findKeyElement(char) {
                const lower = char.toLowerCase();
                // Select by data-char
                return document.querySelector(`.key[data-char="${lower}"]`);
            }

            highlightKey(char) {
                // Remove old active
                document.querySelectorAll('.key.active').forEach(el => el.classList.remove('active'));
                const el = this.findKeyElement(char);
                if (el) el.classList.add('active');
            }

            updateDisplay() {
                const current = this.targetString[this.currentIndex];
                const next = this.targetString.substring(this.currentIndex + 1, this.currentIndex + 10);
                
                this.ui.display.current.textContent = current === " " ? "‚ê£" : current;
                this.ui.display.next.textContent = next.replace(/ /g, "‚ê£");

                const pct = (this.currentIndex / this.targetString.length) * 100;
                this.ui.display.bar.style.width = `${pct}%`;
            }

            levelComplete() {
                this.isGameActive = false;
                this.audio.playWin();
                
                // Unlock next level
                if (this.currentLevelIdx + 1 >= this.unlockedLevels) {
                    this.unlockedLevels++;
                    localStorage.setItem('tastenZauberLevel', this.unlockedLevels);
                }

                document.getElementById('modal-title').innerText = "Klasse gemacht!";
                document.getElementById('modal-desc').innerText = "Jetzt f√ºttere das Tier!";
                document.getElementById('btn-modal-action').innerText = "F√ºttern spielen";
                this.showScreen('modal');
            }

            // --- MINI GAME: Falling Letters ---
            startMiniGame() {
                this.showScreen('none'); // Hide UI
                const canvas = document.getElementById('mini-game-canvas');
                canvas.style.display = 'block';
                const ctx = canvas.getContext('2d');
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;

                const letters = [];
                const possible = LEVELS[this.currentLevelIdx].keys + LEVELS[this.currentLevelIdx].keys.toUpperCase();
                let gameRunning = true;
                let fedCount = 0;
                const maxFed = 10;

                // Spawn Loop
                const spawner = setInterval(() => {
                    if (!gameRunning) return;
                    const char = possible.charAt(Math.floor(Math.random() * possible.length));
                    letters.push({
                        char: char,
                        x: Math.random() * (canvas.width - 100) + 50,
                        y: -50,
                        speed: 2 + Math.random() * 2
                    });
                }, 1000);

                // Input for Mini Game
                const miniHandler = (e) => {
                    const char = e.key;
                    // Find matching falling letter
                    const idx = letters.findIndex(l => l.char === char && l.y < canvas.height - 100);
                    if (idx > -1) {
                        letters.splice(idx, 1);
                        fedCount++;
                        this.audio.playCorrect();
                        this.world.jump(); // Mascot jumps
                        if(fedCount >= maxFed) endGame();
                    }
                };
                window.addEventListener('keydown', miniHandler);

                const endGame = () => {
                    gameRunning = false;
                    clearInterval(spawner);
                    window.removeEventListener('keydown', miniHandler);
                    canvas.style.display = 'none';
                    
                    // Back to Level Select
                    this.showScreen('level');
                };

                // Render Loop
                const loop = () => {
                    if (!gameRunning) return;
                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    // Draw "Mouth" zone at bottom
                    ctx.fillStyle = "rgba(255, 154, 162, 0.5)";
                    ctx.beginPath();
                    ctx.arc(canvas.width/2, canvas.height, 100, Math.PI, 0);
                    ctx.fill();
                    ctx.fillStyle = "white";
                    ctx.font = "20px Fredoka";
                    ctx.fillText(`Futter: ${fedCount}/${maxFed}`, canvas.width/2 - 40, canvas.height - 20);

                    // Draw Letters
                    ctx.font = "bold 40px Fredoka";
                    ctx.fillStyle = "white";
                    for (let i = 0; i < letters.length; i++) {
                        const l = letters[i];
                        l.y += l.speed;
                        ctx.fillText(l.char, l.x, l.y);

                        // Missed letter
                        if (l.y > canvas.height) {
                            letters.splice(i, 1);
                            i--;
                        }
                    }
                    requestAnimationFrame(loop);
                };
                loop();
            }
        }

        // --- INIT ---
        window.onload = () => {
            const app = new Game();
        };

    </script>
</body>
</html>
