<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tipp-Zoo: Das lustige Tipp-Spiel</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&family=Quicksand:wght@500;700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a2e;
            font-family: 'Quicksand', sans-serif;
            color: white;
            user-select: none;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none; /* Let clicks pass through to canvas if needed */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        /* Header / HUD */
        header {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(to bottom, rgba(0,0,0,0.4), transparent);
            pointer-events: auto;
        }

        h1 {
            font-family: 'Fredoka One', cursive;
            font-size: 2rem;
            margin: 0;
            color: #FFD700;
            text-shadow: 2px 2px 0px #ff6b6b;
            letter-spacing: 2px;
        }

        .hud-stats {
            display: flex;
            gap: 20px;
            font-size: 1.2rem;
            font-weight: bold;
            background: rgba(255,255,255,0.2);
            padding: 10px 20px;
            border-radius: 30px;
            backdrop-filter: blur(5px);
        }

        /* Center Play Area */
        #game-center {
            text-align: center;
            pointer-events: none;
            position: absolute;
            top: 20%;
            width: 100%;
        }

        .instruction {
            font-size: 1.5rem;
            color: #fff;
            text-shadow: 0 0 10px rgba(255,105,180, 0.8);
            margin-bottom: 20px;
            opacity: 0.9;
        }

        /* Keyboard Overlay */
        #virtual-keyboard {
            pointer-events: auto;
            margin: 0 auto 20px auto;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 15px;
            display: inline-block;
            backdrop-filter: blur(5px);
            border: 2px solid rgba(255,255,255,0.1);
        }

        .kb-row {
            display: flex;
            justify-content: center;
            gap: 5px;
            margin-bottom: 5px;
        }

        .key {
            width: 40px;
            height: 40px;
            background: #fff;
            color: #333;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-family: 'Fredoka One', cursive;
            box-shadow: 0 4px 0 #ccc;
            transition: transform 0.1s;
        }

        .key.active {
            background: #ff6b6b;
            color: white;
            transform: translateY(4px);
            box-shadow: 0 0 0 #ccc;
        }

        .key.target {
            background: #4ecdc4;
            color: white;
            animation: pulse-key 1s infinite;
        }

        @keyframes pulse-key {
            0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(78, 205, 196, 0.7); }
            70% { transform: scale(1.1); box-shadow: 0 0 0 10px rgba(78, 205, 196, 0); }
            100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(78, 205, 196, 0); }
        }

        /* Screens */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: auto;
            transition: opacity 0.5s;
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
            display: none !important;
        }

        .btn {
            background: linear-gradient(45deg, #ff6b6b, #ff8e53);
            border: none;
            padding: 15px 40px;
            font-size: 1.5rem;
            color: white;
            font-family: 'Fredoka One', cursive;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
            transition: transform 0.2s;
            margin: 10px;
        }

        .btn:hover {
            transform: scale(1.05) rotate(-2deg);
        }

        .settings-panel {
            position: absolute;
            bottom: 20px;
            right: 20px;
            pointer-events: auto;
            display: flex;
            gap: 10px;
        }
        
        .icon-btn {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon-btn.off {
            opacity: 0.5;
            background: rgba(255,0,0,0.2);
        }

        /* Poop Animation text style */
        .poop-text {
            position: absolute;
            font-family: 'Fredoka One', cursive;
            color: #8B4513; /* Brown */
            font-size: 2rem;
            pointer-events: none;
            animation: floatUp 2s ease-out forwards;
            text-shadow: 2px 2px 0px white;
            z-index: 50;
        }

        @keyframes floatUp {
            0% { transform: translateY(0) scale(0.5); opacity: 0; }
            20% { transform: translateY(-20px) scale(1.2); opacity: 1; }
            100% { transform: translateY(-100px) scale(1); opacity: 0; }
        }

        h2 { font-family: 'Fredoka One'; color: #4ecdc4; margin-bottom: 10px; }
        p { max-width: 600px; line-height: 1.6; }

    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <header>
            <h1>üê∂ Tipp-Zoo</h1>
            <div class="hud-stats">
                <span id="level-display">Level: 1</span>
                <span id="score-display">‚≠ê: 0</span>
            </div>
        </header>

        <div id="game-center">
            <div class="instruction" id="instruction-text">F√ºttere den Hund! Dr√ºcke: <span style="color:#ff6b6b; font-weight:bold; font-size:2rem;">F</span></div>
        </div>

        <div style="flex-grow: 1;"></div> <div style="text-align: center;">
            <div id="virtual-keyboard">
                </div>
        </div>

        <div class="settings-panel">
            <button class="icon-btn" id="btn-music" title="Musik">üéµ</button>
            <button class="icon-btn" id="btn-sfx" title="Soundeffekte">üîä</button>
        </div>
    </div>

    <div id="start-screen" class="screen">
        <h1 style="font-size: 4rem; margin-bottom: 0;">Tipp-Zoo</h1>
        <h2 style="color:white; margin-top:0;">Das magische Buchstaben-Abenteuer</h2>
        <p>Willkommen im leuchtenden Zauberwald! <br> Buchstaben fallen vom Himmel. <br> Tippe die richtigen Tasten, um deinen magischen Tierfreund zu f√ºttern.</p>
        <button class="btn" id="start-btn">Spiel Starten ‚ñ∂</button>
        <p style="font-size: 0.8rem; opacity: 0.7;">Ben√∂tigt eine Tastatur.</p>
    </div>

    <div id="level-screen" class="screen hidden">
        <h1 style="color: #FFD700;">Lecker! üçñ</h1>
        <p id="level-msg">Dein Tier ist satt und gl√ºcklich!</p>
        <div style="font-size: 5rem; margin: 20px;">üí©‚ú®</div>
        <p>Ups! Ein lustiges Buchstaben-H√§ufchen!</p>
        <button class="btn" id="next-level-btn">N√§chstes Tier ‚ñ∂</button>
    </div>

<script>
/**
 * APP STATE & CONFIG
 */
const CONFIG = {
    levels: [
        { keys: "fj", name: "Level 1: F & J" },
        { keys: "dk", name: "Level 2: D & K" },
        { keys: "sl", name: "Level 3: S & L" },
        { keys: "a√∂", name: "Level 4: A & √ñ" },
        { keys: "gh", name: "Level 5: G & H" },
        { keys: "rtzuiop√º", name: "Level 6: Oben" },
        { keys: "yxcvbnm", name: "Level 7: Unten" },
        { keys: "qwertzuiopasdfghjklyxcvbnm", name: "Meister!" }
    ],
    colors: [0xff6b6b, 0x4ecdc4, 0xffd93d, 0xff9ff3, 0x6c5ce7],
    animalShapes: ['dog', 'cat', 'bear', 'rabbit'],
    gravity: 0.03
};

const STATE = {
    currentLevel: 0,
    score: 0,
    activeLetter: null,
    isPlaying: false,
    fallingLetters: [],
    settings: { music: true, sfx: true },
    typedCount: 0, // In current level
    requiredToPass: 10
};

/**
 * THREE.JS SETUP (Visuals)
 */
let scene, camera, renderer, clock;
let particles, particleSystem;
let animalGroup; 
let pointCloudMaterial;
let fallingGroup; // Group for falling 3D letters

function initThree() {
    const container = document.getElementById('canvas-container');
    
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x1a1a2e, 0.02);

    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 15;
    camera.position.y = 5;
    camera.lookAt(0, 2, 0);

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);

    clock = new THREE.Clock();

    // Lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    
    const dirLight = new THREE.DirectionalLight(0xffd700, 0.8);
    dirLight.position.set(5, 10, 7);
    scene.add(dirLight);

    // Background Particles (Starfield)
    const starGeo = new THREE.BufferGeometry();
    const starCount = 2000;
    const starPos = new Float32Array(starCount * 3);
    for(let i=0; i<starCount*3; i++) {
        starPos[i] = (Math.random() - 0.5) * 100;
    }
    starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
    const starMat = new THREE.PointsMaterial({color: 0xffffff, size: 0.2, transparent: true, opacity: 0.8});
    const starField = new THREE.Points(starGeo, starMat);
    scene.add(starField);

    // Floor Grid (Synthwave style)
    const gridHelper = new THREE.GridHelper(100, 50, 0x4ecdc4, 0x222244);
    gridHelper.position.y = -2;
    scene.add(gridHelper);

    // Groups
    animalGroup = new THREE.Group();
    animalGroup.position.set(0, -1, 0);
    scene.add(animalGroup);

    fallingGroup = new THREE.Group();
    scene.add(fallingGroup);

    // Initial Animal
    createPointAnimal(0);

    window.addEventListener('resize', onWindowResize, false);
    animate();
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

// Shader for glowing points
const glowShader = {
    vertexShader: `
        attribute float size;
        attribute vec3 customColor;
        varying vec3 vColor;
        void main() {
            vColor = customColor;
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            gl_PointSize = size * (300.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;
        }
    `,
    fragmentShader: `
        uniform vec3 color;
        uniform sampler2D pointTexture;
        varying vec3 vColor;
        void main() {
            vec2 cxy = 2.0 * gl_PointCoord - 1.0;
            float r = dot(cxy, cxy);
            if (r > 1.0) discard;
            float glow = 1.0 - r;
            gl_FragColor = vec4(vColor * glow * 1.5, 1.0); // Simple circle gradient
        }
    `
};

// Procedural Animal Generator (Point Cloud)
function createPointAnimal(levelIndex) {
    // Clear previous
    while(animalGroup.children.length > 0){ 
        animalGroup.remove(animalGroup.children[0]); 
    }

    const geometry = new THREE.BufferGeometry();
    const positions = [];
    const colors = [];
    const sizes = [];

    // Base color based on level
    const baseColor = new THREE.Color(CONFIG.colors[levelIndex % CONFIG.colors.length]);

    // Generate Shape roughly looking like an animal head
    // We use spheres of points
    const addSphere = (ox, oy, oz, rad, count, rScale=1, gScale=1, bScale=1) => {
        for(let i=0; i<count; i++) {
            const phi = Math.acos( -1 + ( 2 * i ) / count );
            const theta = Math.sqrt( count * Math.PI ) * phi;
            
            const x = ox + rad * Math.sin(phi) * Math.cos(theta);
            const y = oy + rad * Math.sin(phi) * Math.sin(theta);
            const z = oz + rad * Math.cos(phi);

            positions.push(x, y, z);
            
            // Varied colors
            colors.push(baseColor.r * rScale, baseColor.g * gScale, baseColor.b * bScale);
            sizes.push(0.3 + Math.random() * 0.2);
        }
    };

    // Head
    addSphere(0, 1.5, 0, 1.5, 800);
    
    // Ears (change based on level/dog type)
    const earY = 2.5 + Math.random();
    addSphere(-1.2, earY, 0, 0.6, 200, 0.8, 0.8, 0.8); // Left
    addSphere(1.2, earY, 0, 0.6, 200, 0.8, 0.8, 0.8); // Right

    // Snout
    addSphere(0, 1, 1.2, 0.6, 300, 1.2, 1.2, 1.2);
    
    // Eyes (Black points)
    const addEye = (x) => {
        for(let k=0; k<50; k++) {
            positions.push(x + (Math.random()-0.5)*0.2, 1.8 + (Math.random()-0.5)*0.2, 1.3);
            colors.push(0,0,0);
            sizes.push(0.4);
        }
    };
    addEye(-0.6);
    addEye(0.6);

    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    geometry.setAttribute('customColor', new THREE.Float32BufferAttribute(colors, 3));
    geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

    const material = new THREE.ShaderMaterial({
        uniforms: {
            color: { value: new THREE.Color(0xffffff) },
        },
        vertexShader: glowShader.vertexShader,
        fragmentShader: glowShader.fragmentShader,
        blending: THREE.AdditiveBlending,
        depthTest: false,
        transparent: true
    });

    const points = new THREE.Points(geometry, material);
    animalGroup.add(points);
}

// 3D Text Generation for Falling Letters
const loader = new THREE.FontLoader();
// We don't have external font file, so we build simple shapes for letters or use canvas texture sprites
function create3DLetter(char) {
    const canvas = document.createElement('canvas');
    canvas.width = 128;
    canvas.height = 128;
    const ctx = canvas.getContext('2d');
    ctx.font = "bold 80px 'Fredoka One'";
    ctx.fillStyle = "#ffffff";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(char.toUpperCase(), 64, 64);

    const texture = new THREE.CanvasTexture(canvas);
    const mat = new THREE.SpriteMaterial({ map: texture, color: 0xffffff });
    const sprite = new THREE.Sprite(mat);
    sprite.scale.set(2, 2, 1);
    
    // Random Start Position
    sprite.position.set((Math.random() - 0.5) * 10, 10, 0);
    sprite.userData = { char: char, speed: 0.02 + Math.random() * 0.03 };
    
    fallingGroup.add(sprite);
    STATE.fallingLetters.push(sprite);
    return sprite;
}

/**
 * TONE.JS SETUP (Audio)
 */
let synth, polySynth, melodySynth, musicLoop;
let drumSynth;

async function initAudio() {
    await Tone.start();
    
    // Main SFX Synth
    synth = new Tone.PolySynth(Tone.Synth, {
        oscillator: { type: "triangle" },
        envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 1 }
    }).toDestination();
    synth.volume.value = -5;

    // Bad Sound Synth
    drumSynth = new Tone.MembraneSynth().toDestination();

    // Music Synth
    melodySynth = new Tone.Synth({
        oscillator: { type: "sine" },
        envelope: { attack: 0.5, decay: 0.2, sustain: 0.5, release: 2 }
    }).toDestination();
    
    const reverb = new Tone.Reverb(2).toDestination();
    melodySynth.connect(reverb);
    melodySynth.volume.value = -15;

    setupMusicLoop();
}

function setupMusicLoop() {
    // Generative pentatonic melody
    const scale = ["C4", "D4", "E4", "G4", "A4", "C5"];
    
    musicLoop = new Tone.Loop(time => {
        if(!STATE.settings.music) return;
        const note = scale[Math.floor(Math.random() * scale.length)];
        // 50% chance to play a note
        if(Math.random() > 0.3) {
            melodySynth.triggerAttackRelease(note, "4n", time);
        }
    }, "4n");
}

function playCorrectSound() {
    if(!STATE.settings.sfx) return;
    const notes = ["C5", "E5", "G5", "C6"];
    const note = notes[Math.floor(Math.random() * notes.length)];
    synth.triggerAttackRelease(note, "8n");
}

function playWrongSound() {
    if(!STATE.settings.sfx) return;
    drumSynth.triggerAttackRelease("C2", "8n");
}

function playLevelWinSound() {
    if(!STATE.settings.sfx) return;
    const now = Tone.now();
    synth.triggerAttackRelease("C4", "8n", now);
    synth.triggerAttackRelease("E4", "8n", now + 0.1);
    synth.triggerAttackRelease("G4", "8n", now + 0.2);
    synth.triggerAttackRelease("C5", "2n", now + 0.3);
}

function playPoopSound() {
    if(!STATE.settings.sfx) return;
    drumSynth.triggerAttackRelease("A1", "4n");
}

/**
 * GAME LOGIC
 */
const germanQWERTZ = [
    ["q","w","e","r","t","z","u","i","o","p","√º"],
    ["a","s","d","f","g","h","j","k","l","√∂","√§"],
    ["y","x","c","v","b","n","m"]
];

function buildKeyboard() {
    const kbContainer = document.getElementById('virtual-keyboard');
    kbContainer.innerHTML = '';

    germanQWERTZ.forEach(row => {
        const rowDiv = document.createElement('div');
        rowDiv.className = 'kb-row';
        row.forEach(char => {
            const keyDiv = document.createElement('div');
            keyDiv.className = 'key';
            keyDiv.id = `key-${char}`;
            keyDiv.textContent = char.toUpperCase();
            rowDiv.appendChild(keyDiv);
        });
        kbContainer.appendChild(rowDiv);
    });
}

function startGame() {
    document.getElementById('start-screen').classList.add('hidden');
    STATE.isPlaying = true;
    STATE.currentLevel = 0;
    STATE.score = 0;
    updateLevel();
    Tone.Transport.start();
    musicLoop.start(0);
}

function updateLevel() {
    STATE.typedCount = 0;
    STATE.requiredToPass = 10 + (STATE.currentLevel * 2);
    
    const lvlConfig = CONFIG.levels[STATE.currentLevel];
    document.getElementById('level-display').textContent = lvlConfig.name;
    document.getElementById('instruction-text').innerHTML = `F√ºttere den Hund! Dr√ºcke Buchstaben aus: <span style="color:#4ecdc4">${lvlConfig.keys.toUpperCase()}</span>`;
    
    createPointAnimal(STATE.currentLevel);
    
    // Clear falling letters
    fallingGroup.children.forEach(c => fallingGroup.remove(c));
    fallingGroup.children = [];
    STATE.fallingLetters = [];

    spawnNextLetter();
}

function spawnNextLetter() {
    if(!STATE.isPlaying) return;
    const lvlConfig = CONFIG.levels[STATE.currentLevel];
    const char = lvlConfig.keys[Math.floor(Math.random() * lvlConfig.keys.length)];
    
    STATE.activeLetter = char;
    create3DLetter(char);
    
    // Highlight Keyboard
    document.querySelectorAll('.key').forEach(k => k.classList.remove('target'));
    const targetKey = document.getElementById(`key-${char}`);
    if(targetKey) targetKey.classList.add('target');
}

function handleInput(e) {
    if(!STATE.isPlaying) return;
    const key = e.key.toLowerCase();
    
    // Visual feedback on keyboard
    const visualKey = document.getElementById(`key-${key}`);
    if(visualKey) {
        visualKey.classList.add('active');
        setTimeout(() => visualKey.classList.remove('active'), 100);
    }

    // Check if key matches the falling letter
    // In this game mode, we only care about the most recent spawned letter or any on screen? 
    // Let's make it simple: Match the LAST spawned letter (the active target).
    
    // Actually, better mechanics for falling text: Iterate all falling letters.
    // If typed key matches closest letter to bottom, destroy it.
    
    // Sort falling letters by Y position (lowest first)
    const sorted = [...STATE.fallingLetters].sort((a,b) => a.position.y - b.position.y);
    const target = sorted[0]; // Lowest letter

    if(target && target.userData.char === key) {
        // CORRECT
        playCorrectSound();
        animalJumpHappy();
        createExplosion(target.position);
        
        // Remove letter
        fallingGroup.remove(target);
        STATE.fallingLetters = STATE.fallingLetters.filter(l => l !== target);
        
        STATE.score += 10;
        STATE.typedCount++;
        document.getElementById('score-display').textContent = `‚≠ê: ${STATE.score}`;
        
        // Next letter?
        if(STATE.fallingLetters.length === 0) {
            spawnNextLetter(); 
        }

        checkLevelProgress();

    } else {
        // WRONG
        if(germanQWERTZ.flat().includes(key)) {
            playWrongSound();
            cameraShake();
        }
    }
}

function checkLevelProgress() {
    if(STATE.typedCount >= STATE.requiredToPass) {
        levelComplete();
    } else if (STATE.fallingLetters.length < 3) {
        // Spawn more if low on screen
        if(Math.random() > 0.5) spawnNextLetter();
    }
}

function createExplosion(pos) {
    const particleCount = 20;
    const geometry = new THREE.BufferGeometry();
    const positions = [];
    const velocities = [];

    for(let i=0; i<particleCount; i++) {
        positions.push(pos.x, pos.y, pos.z);
        velocities.push(
            (Math.random()-0.5)*0.5,
            (Math.random()-0.5)*0.5,
            (Math.random()-0.5)*0.5
        );
    }
    
    const mat = new THREE.PointsMaterial({color: 0xffd700, size: 0.5});
    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    
    const pSystem = new THREE.Points(geometry, mat);
    pSystem.userData = { velocities: velocities, age: 0 };
    scene.add(pSystem);
    
    // Simple animation loop handler specifically for explosions would be cleaner,
    // but we'll hack it into main animate loop via a global array if needed.
    // For single file simplicity, let's use a quick tween-like interval or add to scene user data
    
    // Let's add to a global list
    if(!window.explosions) window.explosions = [];
    window.explosions.push(pSystem);
}

function animalJumpHappy() {
    // Simple Jump
    const startY = -1;
    let velocity = 0.2;
    
    const jumpInterval = setInterval(() => {
        animalGroup.position.y += velocity;
        velocity -= 0.02; // Gravity
        
        animalGroup.rotation.y += 0.1; // Spin

        if(animalGroup.position.y <= startY) {
            animalGroup.position.y = startY;
            animalGroup.rotation.y = 0;
            clearInterval(jumpInterval);
        }
    }, 16);
}

function cameraShake() {
    const originalX = 0;
    let duration = 10;
    const shake = setInterval(() => {
        camera.position.x = (Math.random() - 0.5) * 0.5;
        duration--;
        if(duration <= 0) {
            camera.position.x = originalX;
            clearInterval(shake);
        }
    }, 20);
}

function levelComplete() {
    STATE.isPlaying = false;
    playLevelWinSound();
    
    // Funny Poop Sequence
    setTimeout(() => {
        animalGroup.position.y = -0.5;
        animalGroup.rotation.x = 0.5; // Bend forward
        
        setTimeout(() => {
             // Create poop text
             const poop = document.createElement('div');
             poop.className = 'poop-text';
             poop.innerHTML = "POOOOP!";
             
             // Project 3D position to 2D screen
             const vector = new THREE.Vector3(0, -1, 0);
             vector.project(camera);
             const x = (vector.x * .5 + .5) * window.innerWidth;
             const y = (-(vector.y * .5) + .5) * window.innerHeight;
             
             poop.style.left = x + 'px';
             poop.style.top = y + 'px';
             document.body.appendChild(poop);
             
             playPoopSound();
             
             // Create 3D Poop particles (Brown letters)
             for(let i=0; i<5; i++){
                 const l = create3DLetter(CONFIG.levels[STATE.currentLevel].keys[0]);
                 l.material.color.setHex(0x8B4513);
                 l.position.set(0, -1, 0);
                 l.userData.speed = -0.1 - Math.random() * 0.1; // Shoot up? no, just drop
             }
             
             setTimeout(() => {
                 // Reset animal
                 animalGroup.rotation.x = 0;
                 if(poop.parentNode) poop.parentNode.removeChild(poop);
                 
                 // Show UI
                 document.getElementById('level-screen').classList.remove('hidden');
                 const msgs = ["Fantastisch!", "Super gemacht!", "Klasse!", "Wow!"];
                 document.getElementById('level-msg').textContent = msgs[Math.floor(Math.random()*msgs.length)];
             }, 1500);

        }, 500);
    }, 500);
}

function nextLevel() {
    document.getElementById('level-screen').classList.add('hidden');
    STATE.currentLevel++;
    if(STATE.currentLevel >= CONFIG.levels.length) STATE.currentLevel = 0; // Loop back or finish
    STATE.isPlaying = true;
    updateLevel();
}

/**
 * ANIMATION LOOP
 */
function animate() {
    requestAnimationFrame(animate);

    const delta = clock.getDelta();
    const time = clock.getElapsedTime();

    // Rotate Animal gently (breathing)
    if(STATE.isPlaying) {
        animalGroup.scale.setScalar(1 + Math.sin(time * 3) * 0.05);
    }

    // Animate Point Cloud Material (color shifting)
    animalGroup.children.forEach(points => {
        if(points.material.uniforms) {
            // Pulse glow or shift hue slightly
            // points.material.uniforms.color.value.offsetHSL(0.001, 0, 0);
        }
    });

    // Move Falling Letters
    if(STATE.isPlaying) {
        STATE.fallingLetters.forEach(sprite => {
            sprite.position.y -= sprite.userData.speed;
            
            // Check if missed (hit floor)
            if(sprite.position.y < -2) {
                // Reset to top to be kind to kids (don't delete, just recycle)
                sprite.position.y = 10;
                sprite.position.x = (Math.random() - 0.5) * 10;
            }
        });

        // Spawn logic: ensure at least one letter is always present
        if(STATE.fallingLetters.length === 0) {
            spawnNextLetter();
        }
    }

    // Animate Explosions
    if(window.explosions) {
        for(let i=window.explosions.length-1; i>=0; i--) {
            const sys = window.explosions[i];
            const positions = sys.geometry.attributes.position.array;
            const vels = sys.userData.velocities;
            
            for(let j=0; j<positions.length; j+=3) {
                positions[j] += vels[j];
                positions[j+1] += vels[j+1];
                positions[j+2] += vels[j+2];
            }
            sys.geometry.attributes.position.needsUpdate = true;
            sys.userData.age += 1;
            sys.material.opacity = 1 - (sys.userData.age / 50);
            
            if(sys.userData.age > 50) {
                scene.remove(sys);
                window.explosions.splice(i, 1);
            }
        }
    }

    renderer.render(scene, camera);
}

/**
 * EVENT LISTENERS
 */
document.addEventListener('keydown', handleInput);

document.getElementById('start-btn').addEventListener('click', () => {
    initAudio().then(startGame);
});

document.getElementById('next-level-btn').addEventListener('click', nextLevel);

// Settings
document.getElementById('btn-music').addEventListener('click', (e) => {
    STATE.settings.music = !STATE.settings.music;
    e.target.classList.toggle('off');
    if(!STATE.settings.music) Tone.Transport.stop(); 
    else Tone.Transport.start();
});

document.getElementById('btn-sfx').addEventListener('click', (e) => {
    STATE.settings.sfx = !STATE.settings.sfx;
    e.target.classList.toggle('off');
});

// Init
buildKeyboard();
initThree();

</script>
</body>
</html>
